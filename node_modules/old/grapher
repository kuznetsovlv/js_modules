#!/usr/bin/env node
/*modules: util.njs*/
/* j npm: xmldom*/

(function () {
	"use strict";
	var util = require('util'),
	    xmldom = require('xmldom'),
	    DOMParser = xmldom.DOMParser,
	    XMLSerializer = xmldom.XMLSerializer;
	    

	function commitDOM (obj, tag) {
		var document = new DOMParser().parseFromString(['<', tag, '></', tag, '>'].join(''), '');
		function _setElement (elem, obj) {
			for (var key in obj) {
				var value = obj[key];
				if (typeof value === 'object') {
					if (value instanceof Array) {
						for (var i = 0, l = value.length; i < l; ++i)
							elem.appendChild(_createElement(value[i], key));
					} else {
						elem.appendChild(_createElement(value, key));
					}
				} else if (key === 'content') {
					elem.appendChild(document.createTextNode(value));
				} else {
					elem.setAttribute(key, value);
				}
			}
		}
		function _createElement (obj, tag) {
			var elem = document.createElement(tag);
			_setElement(elem, obj);
			return elem;
		}
		_setElement(document.documentElement, obj);
		return document;
	}

	function getById (obj, id) {
		if (obj.id === id)
			return obj;
		for (var key in obj) {
			var value = obj[key];
			if (typeof value !== 'object')
				continue;
			value = getById(value, id);
			if (value)
				return value;
		}
		return undefined;
	}

	function preDOM (obj) {
		var size = null,
		    axis = null,
		    converter = {
		    	x_g: 0,
		    	y_g: 0,
		    	width: 0,
		    	height: 0,
		    	x_min: 0,
		    	x_max: 0,
		    	x_step: 0,
		    	x_shift: 0,
		    	y_min: 0,
		    	y_max: 0,
		    	y_step: 0,
		    	y_shift: 0,
		    	x: function (x) {
		    		return this.x_g + this.width * (x - this.x_min) / (this.x_max - this.x_min);
		    	},
		    	y: function (y) {
		    		return this.y_g + this.height * (this.y_max - y) / (this.y_max - this.y_min);
		    	}
		    }, 
		    elem;

		function _drawPoint (coords, points) {
			var size = points.size || 0,
			    path = util.clone(points, 'stroke,stroke-width,fill'),
			    x1, x2, y1, y2;
			switch (points.shape) {
				case 'horizontal':
					size /= 2;
					path.d = ['M', coords.x - size, coords.y, 'L', coords.x + size, coords.y, 'Z'].join(' ');
					break;
				case 'vertical':
					size /= 2;
					path.d = ['M', coords.x, coords.y - size, 'L', coords.x, coords.y + size, 'Z'].join(' ');
					break;
				case 'pluss':
					size /= 2;
					path.d = [
						'M', coords.x, coords.y - size, 'L', coords.x, coords.y + size, 'Z',
						'M', coords.x - size, coords.y, 'L', coords.x + size, coords.y, 'Z'
					].join(' ');
					break;
				case 'cross':
					size /= 2;
					var d = size / Math.sqrt(2);
					x1 = coords.x - d;
					x2 = coords.x + d;
					y1 = coords.y - d;
					y2 = coords.y + d;
					path.d = [
						'M', x1, y1, 'L', x2, y2, 'Z',
						'M', x1, y2, 'L', x2, y1, 'Z'
					].join(' ');
					break;
				case 'snow':
					size /= 2;
					var d = size / Math.sqrt(2);
					x1 = coords.x - d;
					x2 = coords.x + d;
					y1 = coords.y - d;
					y2 = coords.y + d;
					path.d = [
						'M', coords.x, coords.y - size, 'L', coords.x, coords.y + size, 'Z',
						'M', coords.x - size, coords.y, 'L', coords.x + size, coords.y, 'Z',
						'M', x1, y1, 'L', x2, y2, 'Z',
						'M', x1, y2, 'L', x2, y1, 'Z'
					].join(' ');
					break;
				case 'triangle':
					var dy = size / 3,
					    dx = dy * Math.sqrt(3);
					y1 = coords.y - 2 * dy;
					y2 = coords.y + dy;
					x1 = coords.x + dx;
					x2 = coords.x - dx;
					path.d = ['M', coords.x, y1, 'L', x1, y2, 'L', x2, y2, 'Z'].join(' ');
					break;
				case 'inv_triangle':
					var dy = size / 3,
					    dx = dy * Math.sqrt(3);
					y1 = coords.y + 2 * dy;
					y2 = coords.y - dy;
					x1 = coords.x + dx;
					x2 = coords.x - dx;
					path.d = ['M', coords.x, y1, 'L', x1, y2, 'L', x2, y2, 'Z'].join(' ');
					break;
				case 'rhomb':
				case 'rhombus':
				case 'diamond':
					size /= 2;
					path.d = ['M', coords.x, coords.y - size, 'L', coords.x + size, coords.y, 'L', coords.x, coords.y + size, 'L', coords.x - size, coords.y, 'Z'].join(' ');
					break;
				case 'square':
					size/= 2;
					x1 = coords.x - size;
					x2 = coords.x + size;
					y1 = coords.y - size;
					y2 = coords.y + size;
					path.d = ['M', x1, y1, 'L', x2, y1, 'L', x2, y2, 'L', x1, y2, 'Z'].join(' ');
					break;
				case 'circle':
				default:
					size /= 2;
					y1 = coords.y + size;
					x1 = coords.x + size;
					path.d = ['M', coords.x, y1, 'A', size, size, 0, 1, 1, x1, coords.y, 'A', size, size, 0, 0, 1, coords.x, y1, 'Z'].join(' ');
			}
			return path;
		}
		function _draw(draw, format, from, to, step) {
			var g = {}, path, points,
			    line = format.line,
			    point = format.points;
			if ((typeof draw === 'function' || line) && line !== 'none') {
				path = {};
				g.path = path;
				if (!line) {
					line = {
						stroke: 'black',
						'stroke-width': '2px',
						type: 'solid'
					};
					format.line = line;
				}
			} else {
				path = null;
			}
			if ((draw instanceof Array || point) && point !== 'none') {
				points = [];
				g.g = {path: points};
				if (!point) {
					point = {
						stroke: 'black',
						'stroke-width': '1px',
						fill: 'black',
						size: 20,
						shape: 'circle'
					};
					format.points = point;
				}
			} else {
				points = null;
			}
			if (line === 'none')
				line = null;
			if (point === 'none')
				point = null;
			if (line) {
				line.fill = 'none';
				switch (line.type) {
					case 'dotted': line['stroke-dasharray'] = '5,5'; break;
					case 'rare dotted': line['stroke-dasharray'] = '5,10'; break;
					case 'dashed': line['stroke-dasharray'] = '10,10'; break;
					case 'long dash': line['stroke-dasharray'] = '25,10'; break;
					case 'dot dash': line['stroke-dasharray'] = '10,5,5,5'; break;
					case '2dot dash': line['stroke-dasharray'] = '10,5,5,5,5,5'; break;
					case '2dot 2dash': line['stroke-dasharray'] = '10,5,10,5,5,5,5,5'; break;
					case '2dot 3dash': line['stroke-dasharray'] = '10,5,10,5,10,5,5,5,5,5'; break;
					case '3dot 3dash': line['stroke-dasharray'] = '10,5,10,5,10,5,5,5,5,5,5,5'; break;
					case 'continuous':
					default: delete line['stroke-dasharray'];
				}
				delete line.type
			}
			if (path) {
					path = util.join(path, line);
					path.d = ['M'];
				}
			if (draw instanceof Array) {
				for (var i = 0, length = draw.length; i < length; ++i) {
					var dot = draw[i];
					if (path)
						path.d.push([dot.x, 'x'].join(''), [dot.y, 'y'].join(''), 'L');
					if (points)
						points.push(_drawPoint({x: converter.x(dot.x), y: converter.y(dot.y)}, point));
				}
			}
			if (typeof draw === 'function') {
				if (!from && from !== 0 || from < converter.x_min)
					from = converter.x_min;
				if(!to && to !== 0 || to > converter.x_max)
					to = converter.x_max;
				if (!step)
					step = converter.x_step / 10;
				if (path)
					for (var i = from; i < to; i += step) {
						path.d.push([i, 'x'].join(''), [draw(i), 'y'].join(''), 'L');
					}
				if (points) {
					step = point.step || step;
					for (var i = from; i < to; i += step) {
						points.push(_drawPoint({x: converter.x(i), y: converter.y(draw(i))}, point));
					}
				}
			}
			if (path)
				path.d.pop();
			return g;
		}
		function _axes_preparse (obj, grid) {
			var tik = obj.tik,
			    numbers = obj.numbers,
			    name = obj.name,
			    axes = obj.id.substr(0, 1),
			    is_x = axes === 'x',
			    axes_ = is_x ? 'y' : 'x';
			function __tiks (tik, grid) {
			
				var line = [],
				    length = tik.length / 2,
				    from = converter[[axes, 'min'].join('_')],
				    to = converter[[axes, 'max'].join('_')],
				    shift = converter[[axes, 'shift'].join('_')],
				    cross = converter[[axes_, 'shift'].join('_')],
				    step = tik.step || converter[[axes, 'step'].join('_')],
				    d1 = [shift - length, axes_].join(''),
				    d2 = [shift + length, axes_].join(''),
				    min = [converter[[axes_, 'min'].join('_')], axes_].join(''),
				    max = [converter[[axes_, 'max'].join('_')], axes_].join('');
				for (var i = from + step; i < to; i += step) {
					if (i === cross)
						continue;
					var p = [i, axes].join(''),
					obj = {
						stroke: tik.color,
						'stroke-width': tik.width,
					},
					tmp = grid ? util.clone(grid) : null;
					if (tmp) {
						delete tmp.id;
						tmp[[axes, 1].join('')] = p;
						tmp[[axes, 2].join('')] = p;
						tmp[[axes_, 1].join('')] = min;
						tmp[[axes_, 2].join('')] = max;
						line.push(tmp);
					}
					obj[[axes, 1].join('')] = p;
					obj[[axes, 2].join('')] = p;
					obj[[axes_, 1].join('')] = d1;
					obj[[axes_, 2].join('')] = d2;
					line.push(obj);
				}
				return line;
			}

			if (!obj.g && (tik || numbers))
				obj.g = {};
			if (tik) {
				if (!obj.g.line)
					obj.g.line = [];
				if (tik.subtik)
					obj.g.line = obj.g.line.concat(__tiks(tik.subtik));
				obj.g.line = obj.g.line.concat(__tiks(tik, grid));
				delete obj.tik;
			}
			if (numbers) {
				if (!numbers.shift)
					numbers.shift = 0;
				if (!obj.g.text)
					obj.g.text = [];
				var g = obj.g,
				    text = g.text,
				    from = converter[[axes, 'min'].join('_')],
				    to = converter[[axes, 'max'].join('_')],
				    shift = converter[[axes, 'shift'].join('_')] + numbers.shift,
				    step = converter[[axes, 'step'].join('_')],
				    cross = converter[[axes === 'x' ? 'y': 'x', 'shift'].join('_')];
				g = util.join(g, {
					'font-family': numbers.font || 'sans-serif',
					'font-size': numbers.size,
					'text-anchor': is_x ? 'middle' : (numbers.shift > 0 ? 'start' : 'end'),
					'alignment-baseline': is_x ? (numbers.shift > 0 ? 'baseline' : 'hanging') : 'middle',
					stroke: numbers.stroke || 'none',
	    		fill: numbers.fill || 'black'
				});
				if (numbers.weight)
	    			g['font-weight'] = numbers.weight;
	    		if (numbers.style)
	    			g['font-weight'] = numbers.style;
	    		for (var i = from + step; i < to; i += step) {
	    			if (i === cross)
	    				continue;
	    			text.push({
	    				content: [i].join(''),
	    				x: [is_x ? i : shift, 'x'].join(''),
	    				y: [is_x ? shift : i, 'y'].join('')
	    			})
	    		}
				delete obj.numbers;
			}
			if (name) {
				if (!obj.g.text)
					obj.g.text = [];
				var shift = converter[[axes, 'shift'].join('_')] + name.shift,
				    text = {
				    content: name.text,
				    	'font-family': name.font || 'sans-serif',
				    	'font-size': name.size,
				    	'text-anchor': 'middle',
				    	'alignment-baseline': 'middle',
				    	stroke: name.stroke || 'none',
				    	fill: name.fill || 'black',
				    	x: [is_x ? name.pos || 0 : shift, 'x'].join(''),
				    	y: [is_x ? shift : name.pos || 0, 'y'].join('')
				    };
				if (!is_x)
					text.transform = ['rotate(',[-90, converter.x(shift), converter.y(name.pos)].join(','), ')'].join('');
				obj.g.text.push(text);
				delete obj.name;
			}
		}
		function _parse (obj) {
			for (var key in obj) {
				var value = obj[key];
				if (typeof value === 'object') {
					obj[key] = _parse(value);
					if (key === 'd' && value instanceof Array)
						obj[key] = value.join(' ');
				} else if (typeof value === 'string'){
					value = value.replace(/^\d+\%[hw]$/, function (w) {
						w = w.split('%');
						return parseInt(w[0]) * parseInt(size[w[1]]) / 100;
					});
					if (typeof value === 'string')
						value = value.replace(/^-?\d*\.?\d+[xy]$/, function (w) {
							return converter[w.substr(-1)](parseFloat(w.slice(0, -1)));
						});
					obj[key] = value;
				}
			}
			return obj;
		}
		/*Preparse size*/
		var viewBox = obj.viewBox;
		if (viewBox) {
			viewBox = viewBox.split(' ');
			if (viewBox[0]) {
				viewBox[2] -= viewBox[0];
				viewBox[0] = 0;
			}
			if (viewBox[1]) {
				viewBox[3] -= viewBox[1];
				viewBox[1] = 0;
			}
			size = {
				w: viewBox[2],
				h: viewBox[3]
			}
			obj.viewBox = viewBox.join(' ');
		}

		/*Preparse graph*/
		elem = getById(obj, 'graph');
		var rect = elem.rect = _parse(elem.rect);
		converter = util.join(converter, {
			x_g: parseFloat(rect.x),
			y_g: parseFloat(rect.y),
			width: parseFloat(rect.width),
			height: parseFloat(rect.height)
		});

		/*Preparse axis*/
		elem = getById(obj, 'axis');
		var x_axes = getById(elem, 'x-axes'),
		    y_axes = getById(elem, 'y-axes'),
		    grid = getById(elem, 'grid'),
		    x = x_axes.line, y = y_axes.line,
		    from = x.from, to = x.to, shift = x.shift || 0;
		converter.x_min = parseFloat(from);
		converter.x_max = parseFloat(to);
		converter.x_step = parseFloat(x.step);
		converter.x_shift = shift;
		x.x1 = [from, 'x'].join('');
		x.x2 = [to, 'x'].join('');
		x.y1 = x.y2 = [shift || 0, 'y'].join('');
		from = y.from; to = y.to; shift = y.shift || 0;
		converter.y_min = parseFloat(from);
		converter.y_max = parseFloat(to);
		converter.y_step = parseFloat(y.step);
		converter.y_shift = shift;
		converter.x_shift_abs=converter.y(converter.x_shift);
		converter.y_shift_abs=converter.x(converter.y_shift);
		y.y1 = [from, 'y'].join('');
		y.y2 = [to, 'y'].join('');
		y.x1 = y.x2 = [shift || 0, 'x'].join('');
		delete x.from;
		delete x.to;
		delete x.shift;
		delete x.step;
		delete y.from;
		delete y.to;
		delete y.shift;
		delete y.step;
		_axes_preparse(x_axes, grid);
		_axes_preparse(y_axes, grid);

		/*Preparse graphs*/
		
		/*
			graph = {name, description, format: {points, line}, draw, from, to, step, nolegend}
		*/
		elem = getById(obj, 'graphs');
		var legend = getById(obj, 'legend'),
		    list = elem.list || {},
		    layout = legend ? legend.layout || 'column' : null;
		if (legend) {
			delete legend.layout;
			_parse(legend);
		}
		if (!elem.g)
			elem.g = [];
		for (var key in list) {
			var graph = list[key],
			    draw = graph.draw,
			    format = graph.format;
			if (draw instanceof Array || typeof draw === 'function') {
				elem.g.push({
					name: graph.name,
					g: _draw(draw, format, graph.from, graph.to, graph.step)
				});
			} else {
				var g = [];
				for (var gr in draw) {
					var tmp = draw[gr];
					g.push(_draw(tmp.graph || tmp, tmp.format || format, graph.from, graph.to, graph.step))
				}
				elem.g.push({
					name: graph.name,
					g: g
				});
			}
			if (legend) {
				if (!legend.list)
					legend.list = [];
				legend.list.push(util.clone(graph, 'name,description,format'))
			}
		}
		delete elem.list;
		if (legend) {
			var x = parseInt(legend.rect.x),
			    y = parseInt(legend.rect.y),
			    width = parseInt(legend.rect.width),
			    height = parseInt(legend.rect.height);
			if (!legend.g)
				legend.g = [];
			while (legend.list.length) {
				var item = legend.list.shift();
				legend.g.push({
					name: item.name,
					g: item.format,
					text: {content: item.description || item.name}
				});
			}
			delete legend.list;
			switch (layout) {
				case 'column':
					var length = legend.g.length,
					    n = length + 1,
					    x0 = x + 0.05 * width,
					    x2 = x0 + 0.2 * width,
					    x1 = (x0 + x2) / 2,
					    x3 = x2 + 0.05 * width,
					    dy = height / n;
					for (var i = 0; i < length; ++i) {
						y += dy;
						var item = legend.g[i],
						    format = item.g;
						item.g = {path: []};
						if (format.line) {
							var path = util.clone(format.line);
							path.d = ['M', x0, y, 'L', x2, y].join(' ');
							item.g.path.push(path);
						}
						if (format.points)
							item.g.path.push(_drawPoint({x: x1, y: y}, format.points));
						item.text = util.join(item.text, {
							'text-anchor': 'start',
							'alignment-baseline': 'middle',
							x: x3,
							y:y
						})
					}
			}
		}
		

		return _parse (obj);
	}

	function createXML (obj) {
		var attrs = [];
		for (var key in obj)
			attrs.push([key, '=', '"', obj[key], '"'].join(''));
		return ['<?xml', attrs.join(' '), '?>'].join(' ');
	}

	var FORMATS = {
	    	A4: {
	    		version:"1.1",
	    		xmlns:"http://www.w3.org/2000/svg",
	    		x: "0px",
	    		y: "0px",
	    		height: "210mm",
	    		width: "297mm",
	    		viewBox: "0 0 2970 2100",
	    		defs: { id: 'defs',
	    			filter: [
	    				{
	    					x: "-50%",
	    					y: "-50%",
	    					width: "200%",
	    					height: "200%",
	    					id: "shadow_000",
	    					feGaussianBlur: {
	    						'in': "SourceAlpha",
	    						stdDeviation: "1",
	    						result: "blur"
	    					},
	    					feOffset: {
	    						'in': "blur",
	    						dx: "1",
	    						dy: "1",
	    						result: "shadow"
	    					},
	    					feMerge: {
	    						feMergeNode: [{'in': "SourceGraphic"}, {'in': "shadow"}]
	    					}
	    				}
	    			]
	    		},
	    		g: [
	    			{
	    				id: 'background',
	    				rect: {
	    					id: "rect_background",
	    					x: "0",
	    					y: "0",
	    					width: "100%w",
	    					height: "100%h",
	    					fill: "white",
	    					stroke:"none"
	    				}
	    			},
	    			{
	    				id: "graph",
	    				rect: {
	    					id: "rect_graph",
	    					x: "2%w",
	    					y: "10%h",
	    					width: "78%w",
	    					height: "88%h",
	    					fill: "white",
	    					stroke:"black",
	    					'stroke-width': '2px'
	    				},
	    				g: [
	    					{
	    						id: "axis",
	    						g: [
	    							{
	    								id: 'x-axes',
	    								line: {
	    									stroke: "black",
	    									'stroke-width': "10px",
	    									from: 0,
	    									to: 100,
	    									shift: 0
	    								}
	    							},
	    							{
	    								id: 'y-axes',
	    								line: {
	    									stroke: "black",
	    									'stroke-width': "10px",
	    									from: 0,
	    									to: 100,
	    									shift: 0
	    								}
	    							}
	    						]
	    					},
	    					{
	    						id: 'graphs'
	    					}
	    				]
	    			},
	    			{
	    				id: "title",
	    				rect: {
	    					id: "rect_title",
	    					x: "0", 
	    					y: "2%h",
	    					width: "100%w",
	    					height: "8%h",
	    					fill: "white",
	    					stroke: "none"
	    				},
	    				text: {
	    					'font-family': "sans-serif",
	    					'font-size': "160",
	    					'font-weight': "bold",
	    					'text-anchor': "middle",
	    					'alignment-baseline': "middle",
	    					stroke: "none",
	    					fill: "black",
	    					id: "text_title",
	    					x: "50%w",
	    					y: "6%h",
	    					content: "Title"
	    				}
	    			},
	    			{
	    				id: "legend",
	    				layout: 'column',
	    				'font-family': "sans-serif",
	    				'font-size': "50",
	    				rect: {
	    					x: '80%w',
	    					y: '10%h',
	    					width: '18%w',
	    					height: '88%h',
	    					stroke: 'black',
	    					'stroke-width': '2px',
	    					fill: 'white'
	    				}
	    			}
	    		]
	    	}
	    },
	    FILTERS = {
	    	shadow: {
	    		x: '-50%',
	    		y: '-50%',
	    		width: '200%',
	    		height: '200%',
	    		feGaussianBlur: {
	    			'in': "SourceAlpha",
	    			stdDeviation: 1,
	    			result: 'blur'
	    		},
	    		feOffset: {
	    			'in': 'blur',
	    			dx: 1,
	    			dy: 1,
	    			result: 'shadow'
	    		},
	    		feMerge: {
	    			feMergeNode: [{'in': 'SourceGraphic'}, {'in': 'shadow'}]
	    		}
	    	}
	    };
	FORMATS['default'] = FORMATS.A4;

	function SVG (format, mod, xml) {
		if (typeof format !== 'object')
			format = util.clone(FORMATS[format] || {});
		if (mod)
			format = utils.join(format, mod);
		if (!xml)
			xml = {};
		xml = util.joiny(xml, {
			version: '1.0',
			standalone: 'no'
		})
		format = util.joiny(format, FORMATS['default']);

		this.setTitle = function (title, title_format) {
			/*
				title_format= {background, text}
			*/
			if (arguments.length === 1 && typeof title === 'object') {
				title_format = title;
				title = null;
			}
			var obj = getById(format, 'title');
			if (!obj) {
				obj = getById(FORMATS['default'], 'title') || {id: 'title', rect: {}, text: {}};
				format.g.push(obj);
			}
			if (title_format) {
				obj.rect = util.join(obj.rect, title_format.background || {});
				obj.text = util.join(obj.text, title_format.text || {});
			}
			if (title)
				obj.text.content = title;
			return this;
		}
		this.setAxis = function (axis) {
			/*axis = {
				x: {stroke, stroke-width, from, to, step, shift, tik: {length, width, color, subtik: {length, width, color, step}}, numbers: {font, size, weight, style, stoke, fill, shift}, name: {text, font, size, weight, style, stoke, fill, shift, pos}},
				y: {stroke, stroke-width, from, to, step, shift, tik: {length, width, color, subtik: {length, width, color, step}}, numbers: {font, size, weight, style, stoke, fill, shift}, name: {text, font, size, weight, style, stoke, fill, shift, pos}},
				grid: {stroke, stroke-width}
			}*/
			var obj = getById(format, 'axis');
			if (!obj) {
				obj = getById(FORMATS['default'], 'axis') || {id: 'axis', g: [{id: 'x-axes', line: {}}, {id: 'y-axes', line: {}}]};
				getById(format, 'graph').g.push(obj);
			}
			var x = getById(obj, 'x-axes'),
			    y = getById(obj, 'y-axes');
			if (!x) {
				x = getById(FORMATS['default'], 'x-axes') || {id: 'x-axes', line: {}};
				obj.g.push(x);
			}
			if (!y) {
				y = getById(FORMATS['default'], 'y-axes') || {id: 'y-axes', line: {}};
				obj.g.push(y);
			}
			x = util.join(x, util.clone(axis.x || {}, 'tik,numbers,name'));
			x.line = util.join(x.line, util.clone(axis.x || {}, 'stroke,stroke-width,from,to,shift,step'));
			y = util.join(y, util.clone(axis.y || {}, 'tik,numbers,name'));
			y.line = util.join(y.line, util.clone(axis.y || {}, 'stroke,stroke-width,from,to,shift,step'));
			if (axis.grid) {
				var grid = getById(obj, 'grid');
				if (!grid) {
					axis.grid.id = 'grid';
					obj.g.push(axis.grid);
				} else {
					grid = util.join(axis.grid);
				}
			}
			return this;
		}

		this.drawGraph = function (graph) {
			/*
				graph = {name, description, format: {points, line}, draw, from, to, step, nolegend}
			*/
			var graphs = getById(format, 'graphs');
			if (!graphs) {
				graphs = {id: 'graphs'};
				var graph_ = getById(format, 'graph');
				if (!graph_.g)
					graph_.g = [];
				graph_.g.push(graphs);
			}
			if (!graphs.list)
				graphs.list = {};
			graphs.list[graph.name] = graph;
			return this;
		}


		this.toString = function toString () {
			return [createXML(xml), '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">', new XMLSerializer().serializeToString(commitDOM(preDOM(format), 'svg').documentElement)].join('\n')
		}
	}

	exports.SVG = function (format) {
		return new SVG(format);
	}
})()